----------------------------RTK Query-----------------------
RTK Query is a powerful data fetching and caching tool built into Redux Toolkit.


It helps for 

Fetch data from APIs
Cache and share the data automatically
Handle loading, success, and error states
Re-fetch and update data easily
Reduce boilerplate code (no more manual thunk or reducers)



Main concepts in RTK Query

1. createApi  -  The main entry point for defining an API service.
2. baseQuery  -  The function that performs the actual API request
3. endpoints  -  Define how to fetch or modify data (queries & mutations)
4. query      -  for Fetching data(GET requests) 
5. mutation   -  For modifying data (POST, PUT, DELETE requests)
6. auto caching & invalidation  -  How RTK Query caches data and knows when to refetch
7. hooks generation  -  Automatically generated hooks for use in React components











Concept	             What It Controls	             Industrial Purpose
createApi	           Defines API service	           Centralizes API logic
baseQuery	           Handles request transport	   Standardizes backend communication
endpoints	           Defines API operations	       Encapsulates logic for each resource
builder.query()	       Fetch (GET) data	               Read operations with auto cache
builder.mutation()	   Send/update data	               Write operations with refetch support
providesTags	       Labels cached data	           Enables auto refresh
invalidatesTags	       Marks data stale	               Ensures consistency after updates
keepUnusedDataFor	   Cache duration	               Balances memory vs performance
refetchOnFocus	       Refresh on tab focus	           Keeps data fresh
refetchOnReconnect	   Refresh on network reconnect	   Ensures reliability
Auto Hooks	           Prebuilt React hooks	           Removes boilerplate
Auto Cache	           Shared data	                   Boosts performance





The keywords inside the createApi


1.createApi: 
  In Redux Toolkit Query (RTK Query), createApi is a function used to define and manage API endpoints â€” like fetching, posting, updating, or deleting data â€” with caching, loading, and error handling built-in.

     You can think of createApi as a replacement for:
       1.createSlice â†’ to store API data
       2.createAsyncThunk â†’ to handle async calls
       3.extraReducers â†’ to update state after API responses
  So basically, createApi does all that automatically.

    createApi() automatically creates several powerful things for you:
      githubApi.reducer --> is the part of your Redux store that stores all the data, cache, and request states managed by RTK Query.
      githubApi.middleware  -->  is what performs the actual side effects â€” the API calls, cache management, invalidation, re-fetching, etc.
      githubApi.reducerPath --> it is just a unique key
      githubApi.endpoints  --> is an object that holds all the query and mutation endpoints you define inside createApi().
      React hooks like   --> RTK Query automatically generates custom React hooks based on your endpoint names.


2.reducerPath: 'pathname'
  1.This is the key name in redux store under which all Api data is stored.
  2.It's like name field in the Redux slice


3.baseQuery: fetchBaseQuery({baseUrl: 'url'})
   1.Defines the base URL for all API requests.
   2.fetchBaseQuery is a small wrapper around the browserâ€™s fetch() API â€” it automatically handles GET, POST, PUT, DELETE, headers, etc.
   3.You can also customize it (e.g., add headers or authentication tokens).
   4.So, baseQuery replaces all the manual fetching logic you write in createAsyncThunk.


4.endpoints:
    This defines all the API endpoints your app uses:
      1.builder.query() â†’ for GET requests
      2.builder.mutation() â†’ for POST, PUT, DELETE requests

   Each endpoint automatically gives you:
     âœ… Data
     âœ… Loading status (isLoading)
     âœ… Error info (error)
     âœ… Auto-caching, re-fetching, etc.

    1.In normal redux, we need createAsyncThunk for fetching, extraReducers for handle pending/fullfilled/rejected, slice for storing data.
    2.endpoints replaces all of these above.

   how do we use builder.query() && builder.mutation():
     getUser: builder.query({ query: (id) => \users/${id}` })`
     addUser: builder.mutation({ query: (body) => ({ url: 'users', method: 'POST', body }) })


Important points:
   
  1. You can export two main things from this file ğŸ‘‡

     a) The API object itself
        const githubApi = createApi({...})
        This is used when adding the reducer and middleware to the store.
     b) The auto-generated React hooks
        Each endpoint automatically creates a custom hook.
        
        You export them like this:
           export const { useGetUserQuery, useAddUserMutation } = githubApi;
        So, youâ€™re exporting:
           useGetUserQuery â†’ for fetching (GET)
           useAddUserMutation â†’ for creating/updating/deleting


  2.Import in Redux Store (store.js)

     import { configureStore } from '@reduxjs/toolkit';
     import { githubApi } from './githubApi';  // âœ… import the API object

     export const store = configureStore({
       reducer: {
         [githubApi.reducerPath]: githubApi.reducer, // âœ… add API reducer
       },
       middleware: (getDefaultMiddleware) =>
         getDefaultMiddleware().concat(githubApi.middleware), // âœ… add middleware
    });

       ğŸ§  Why these two are needed:
            githubApi.reducer â†’ stores data, cache, loading states.
            githubApi.middleware â†’ handles API requests, caching, and refetching logic.



  3.Import in react Components:
     For Query (GET):
       const { data, error, isLoading } = useGetUserQuery('srinivas');
     For Mutation (POST/PUT/DELETE):
       const [addUser, { isLoading }] = useAddUserMutation();
       const handleAddUser = async () => {
         await addUser({ name: 'Srinivas', age: 23 });
       };


  
 4.Redux store:
    Redux Store as a central container (or database) that holds the entire state of your React app.

    When you use normal Redux Toolkit, your store setup looks like this:

       import { configureStore } from "@reduxjs/toolkit";
       import userReducer from "./userSlice";

      export const store = configureStore({
        reducer: {
        user: userReducer,
       },
      });

     ğŸ§  Inside this store:
        {
            user: {
            name: "Srinivas",
            age: 21
          }
        }


    Inside the store, RTK Query saves structured data like this:
      {
        githubApi: {
          queries: {
            'getUser("srinivas")': {
              status: 'fulfilled',
              data: { name: 'Srinivas', followers: 12 },
              error: undefined,
            },
            'getRepos("srinivas")': {
              status: 'pending',
              data: undefined,
            }
          },
          mutations: {
            'updateProfile': {
              status: 'fulfilled',
              data: { success: true }
            }
          },
          provided: {
            User: ['srinivas']
          },
          subscriptions: {
           'getUser("srinivas")': { refCount: 1 }
          }
        }
      }
   
    Meaning:
     queries â†’ stores all data fetched via useQuery
     mutations â†’ stores states for useMutation (POST, PUT, DELETE)
     provided â†’ tracks cache invalidation relationships

    So the Redux store is not only holding your appâ€™s UI state, but also:
       Fetched data
       Loading states
       Errors 
       Cache timestamps


  5. Middleware:
    middleware is the middle layer between the react components(dispatching actions) and redux reducers(updating state)
    Middleware can intercept actions before they reach the reducers, so it can perform extra logic like logging, async API calls, or modifying data.
     
 
  6. providesTags, invalidatesTags, keepUnusedDataFor :
     
    When you fetch data with RTK Query, it automatically stores (caches) that data in Redux.
       a. But how long should it stay?
       b. When should it refetch?
       c. When you add/update/delete something â€” should it reload old data automatically?


    A) provideTags:
      When a query fetches data, it can be â€œtaggedâ€ with a label â€” like giving that piece of cache a name.
        getUsers: builder.query({
            query: () => '/users',
            providesTags: ['Users'], // ğŸ·ï¸ This cache is labeled "Users"
        })

    B) invalidatesTags:
      Used in mutations (POST, PUT, DELETE).
      This change makes some cached data outdated. Invalidate those tags so they get refetched.
        addUser: builder.mutation({
          query: (user) => ({
          url: '/users',
          method: 'POST',
          body: user,
         }),
        invalidatesTags: ['Users'], // ğŸ’£ Invalidate "Users" cache
      }),

      When you call addUser(), RTK Query will:
        Mark the Users cache (from getUsers) as stale.
        Automatically refetch getUsers query.
        So your UI updates automatically â€” no manual refetch needed!

    C) keepUnusedDataFor:
      Controls how long RTK Query keeps unused cache data in memory (default = 60 seconds).
      getUsers: builder.query({
        query: () => '/users',
        keepUnusedDataFor: 300, // â³ 5 minutes
      })



  7) RTK Query Hook Calling Methods:
    a)Using the Trigger Function (Recommended):
     const [registerUser, { data, error, isLoading }] = useRegisterMutation();
     const handleSubmit = async (e) => {
          e.preventDefault();
          try {
            const response = await registerUser(formData).unwrap();
            console.log("âœ… Registered Successfully:", response);
          } catch (err) {
               console.error("âŒ Registration Failed:", err);
            }
      };

    âœ… Advantages: 
        You have full control over when the API runs.
        You can pass dynamic data (form input, parameters, etc.).
        You can handle errors easily with .unwrap().
        Works perfectly for forms, button clicks, or conditional calls.
    ğŸ’¡ Use Case:
       For mutations (POST, PUT, DELETE) or queries triggered by user action.


    1ï¸âƒ£ Basic Meaning of .unwrap():
        that function returns a special Promise â€” not a normal one.
        It contains metadata (like isLoading, isSuccess, etc.), but it doesnâ€™t directly give you the raw API response or error.
        It â€œunwrapsâ€ the mutation result into a standard JavaScript Promise that resolves or rejects normally.
   